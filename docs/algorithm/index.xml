<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Codiy's Notebook – Algorithms</title><link>https://note.codiy.net/docs/algorithm/</link><description>Recent content in Algorithms on Codiy's Notebook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 19 Apr 2020 22:06:13 +0800</lastBuildDate><atom:link href="https://note.codiy.net/docs/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 01-冒泡排序</title><link>https://note.codiy.net/docs/2020/04/01-bubble/</link><pubDate>Tue, 21 Apr 2020 20:54:40 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/01-bubble/</guid><description>
&lt;h2 id="1-基本思想">1 基本思想&lt;/h2>
&lt;p>冒泡排序算法是重复地走访要排序的数列，一次比较相邻的两个元素，如果他们的顺序与排序要求相反，就将它们互换，直到没有再需要交换的数字，则说明排序完成。&lt;/p>
&lt;h2 id="2-算法过程">2 算法过程&lt;/h2>
&lt;p>1、比较相邻的两个元素，如果前面的数大于后面的数，就将两个数进行交换；&lt;/p>
&lt;p>2、从开始第一对到结尾的最后一对，对每一对相邻元素作第1）操作。这步做完后，最大的数就会沉到数组的最后。&lt;/p>
&lt;p>3、然后再从头开始，重复第 1 和第 2 操作，直到倒数第二位时结束。&lt;/p>
&lt;h2 id="3-算法图解">3 算法图解&lt;/h2>
&lt;p>
&lt;p class="md__image">
&lt;img
src="https://img.codiy.net/algorithm/2020/04/bubble.gif"
alt="冒泡排序算法示意图"
/>
&lt;/p>&lt;/p>
&lt;h2 id="4-php代码实现">4 PHP代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 冒泡排序: 循环n-1次, 每次使最大的往后面放, 交换相邻两元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 时间复杂度: O(n2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 空间复杂度: O(1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 稳定排序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">bubbleSort&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$length&lt;/span> = count(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$i&lt;/span> = &lt;span style="color:#b452cd">1&lt;/span>; &lt;span style="color:#00688b">$i&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span>; ++&lt;span style="color:#00688b">$i&lt;/span>) { &lt;span style="color:#228b22">// 循环 $length - 1 次
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#b452cd">0&lt;/span>; &lt;span style="color:#00688b">$j&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span> - &lt;span style="color:#00688b">$i&lt;/span> ; ++&lt;span style="color:#00688b">$j&lt;/span>) {&lt;span style="color:#228b22">// 每次使最大的放到最后
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>] &amp;lt; &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>]) {&lt;span style="color:#228b22">// 交换相邻两元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">list&lt;/span>(&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>]) = [&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>]];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$arr&lt;/span> = [&lt;span style="color:#b452cd">38&lt;/span>, &lt;span style="color:#b452cd">19&lt;/span>, &lt;span style="color:#b452cd">29&lt;/span>, &lt;span style="color:#b452cd">91&lt;/span>, &lt;span style="color:#b452cd">85&lt;/span>, &lt;span style="color:#b452cd">12&lt;/span>, &lt;span style="color:#b452cd">41&lt;/span>, &lt;span style="color:#b452cd">21&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bubbleSort(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print_r(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-效率分析">5 效率分析&lt;/h2>
&lt;p>1、时间复杂度：O(n²)
最好的情况：待排序记录按关键字从小到大排列（正序），需要比较n-1次，时间复杂度为O(n);
最坏的情况：待排序记录按关键字从大到小排列（逆序），需要比较n-1+n-2+…+1=n(n-1)/2，交换次数和比较次数等值，时间复杂度依然为O(n²)。
2、空间复杂度：O(1)，是稳定排序&lt;/p>
&lt;h2 id="6-算法改进">6 算法改进&lt;/h2>
&lt;p>TODO 设置标志变量$swapped&lt;/p></description></item><item><title>Docs: 02-插入排序</title><link>https://note.codiy.net/docs/2020/04/02-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link><pubDate>Tue, 21 Apr 2020 21:42:04 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/02-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid><description>
&lt;h2 id="1-基本思想">1 基本思想&lt;/h2>
&lt;p>插入排序算法是每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到所有元素插入完毕为止。&lt;/p>
&lt;h2 id="2-算法过程">2 算法过程&lt;/h2>
&lt;p>1、将第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；&lt;/p>
&lt;p>2、从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面，这样的插入方式，排序是稳定的）。&lt;/p>
&lt;h2 id="3-算法图解">3 算法图解&lt;/h2>
&lt;p>
&lt;p class="md__image">
&lt;img
src="https://img.codiy.net/algorithm/2020/04/insert.gif"
alt="算法图解"
/>
&lt;/p>&lt;/p>
&lt;h2 id="4-php代码实现">4 PHP代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 插入排序: 每次往后多取一个元素, 和现有元素从后往前逐个比较, 比较大,就将现有元素后移一位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 时间复杂度: O(n2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 空间复杂度: O(1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 稳定排序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">insertSort&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$length&lt;/span> = count(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$i&lt;/span> = &lt;span style="color:#b452cd">1&lt;/span>; &lt;span style="color:#00688b">$i&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span>; ++&lt;span style="color:#00688b">$i&lt;/span>) {&lt;span style="color:#228b22">// 每次往后多取一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#00688b">$temp&lt;/span> = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#00688b">$i&lt;/span> - &lt;span style="color:#b452cd">1&lt;/span>; &lt;span style="color:#00688b">$j&lt;/span> &amp;gt;= &lt;span style="color:#b452cd">0&lt;/span>; --&lt;span style="color:#00688b">$j&lt;/span>) {&lt;span style="color:#228b22">// 和现有元素逐个从后往前比较
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] &amp;gt; &lt;span style="color:#00688b">$temp&lt;/span>) { &lt;span style="color:#228b22">// 比较大,就将现有元素后移一位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] = &lt;span style="color:#00688b">$temp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#8b008b;font-weight:bold">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$arr&lt;/span> = [&lt;span style="color:#b452cd">38&lt;/span>, &lt;span style="color:#b452cd">19&lt;/span>, &lt;span style="color:#b452cd">29&lt;/span>, &lt;span style="color:#b452cd">91&lt;/span>, &lt;span style="color:#b452cd">85&lt;/span>, &lt;span style="color:#b452cd">12&lt;/span>, &lt;span style="color:#b452cd">41&lt;/span>, &lt;span style="color:#b452cd">21&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>insertSort(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print_r(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">insertSort2&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$length&lt;/span> = count(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$i&lt;/span> = &lt;span style="color:#b452cd">1&lt;/span>; &lt;span style="color:#00688b">$i&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span>; ++&lt;span style="color:#00688b">$i&lt;/span>) {&lt;span style="color:#228b22">// 每次往前多取一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#b452cd">0&lt;/span>; &lt;span style="color:#00688b">$j&lt;/span> &amp;lt; &lt;span style="color:#00688b">$i&lt;/span>; ++&lt;span style="color:#00688b">$j&lt;/span>) {&lt;span style="color:#228b22">// 和现有元素逐个从前往后比较
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] &amp;gt; &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>]) { &lt;span style="color:#228b22">// 找到第一个比它大的元素, 交换, 后续元素往后移一位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">list&lt;/span>(&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>]) = [&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>]];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$arr&lt;/span> = [&lt;span style="color:#b452cd">38&lt;/span>, &lt;span style="color:#b452cd">19&lt;/span>, &lt;span style="color:#b452cd">29&lt;/span>, &lt;span style="color:#b452cd">91&lt;/span>, &lt;span style="color:#b452cd">85&lt;/span>, &lt;span style="color:#b452cd">12&lt;/span>, &lt;span style="color:#b452cd">41&lt;/span>, &lt;span style="color:#b452cd">21&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>insertSort2(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print_r(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-效率分析">5 效率分析&lt;/h2>
&lt;p>1、时间复杂度：O(n²)
最好的情况：待排序记录按关键字从小到大排列（正序），需要比较n-1次，不需要交换元素，时间复杂度为O(n);
最坏的情况：待排序记录按关键字从大到小排列（逆序），时间复杂度为O(n²)。
2、空间复杂度：O(1)，是稳定排序。&lt;/p></description></item><item><title>Docs: 03-选择排序</title><link>https://note.codiy.net/docs/2020/04/03-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link><pubDate>Tue, 21 Apr 2020 22:40:14 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/03-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid><description>
&lt;h2 id="1-基本思想">1 基本思想&lt;/h2>
&lt;p>选择排序算法是从前往后遍历元素，每次假定当前元素为最小元素，再次遍历剩余元素，找到找到真正最小的元素，交换位置，直到元素有序。&lt;/p>
&lt;h2 id="2-算法过程">2 算法过程&lt;/h2>
&lt;p>1、将第一个元素当成最小元素，跟它后面的元素逐个比较，暂存最小元素的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小数
2、下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小数
3、重复以上步骤，直到有序&lt;/p>
&lt;h2 id="3-算法图解">3 算法图解&lt;/h2>
&lt;p>
&lt;p class="md__image">
&lt;img
src="https://img.codiy.net/algorithm/2020/04/select.gif"
alt="算法图解"
/>
&lt;/p>&lt;/p>
&lt;h2 id="4-php代码实现">4 PHP代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 选择排序: 选一个假定的最小, 找到比他小的, 交换位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 时间复杂度: O(n2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 空间复杂度: O(2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 稳定排序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">selectSort&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$length&lt;/span> = count(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$i&lt;/span> = &lt;span style="color:#b452cd">0&lt;/span>; &lt;span style="color:#00688b">$i&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span>; ++&lt;span style="color:#00688b">$i&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$minIdx&lt;/span> = &lt;span style="color:#00688b">$i&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#00688b">$i&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>; &lt;span style="color:#00688b">$j&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span>; ++&lt;span style="color:#00688b">$j&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] &amp;lt; &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$minIdx&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$minIdx&lt;/span> = &lt;span style="color:#00688b">$j&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$minIdx&lt;/span> != &lt;span style="color:#00688b">$i&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">list&lt;/span>(&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$minIdx&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>]) = [&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$minIdx&lt;/span>]];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$arr&lt;/span> = [&lt;span style="color:#b452cd">38&lt;/span>, &lt;span style="color:#b452cd">19&lt;/span>, &lt;span style="color:#b452cd">29&lt;/span>, &lt;span style="color:#b452cd">91&lt;/span>, &lt;span style="color:#b452cd">85&lt;/span>, &lt;span style="color:#b452cd">12&lt;/span>, &lt;span style="color:#b452cd">41&lt;/span>, &lt;span style="color:#b452cd">21&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>selectSort(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print_r(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-效率分析">5 效率分析&lt;/h2>
&lt;p>1、时间复杂度O(n2)
(n-1) + (n-2) + &amp;hellip; + 1 ==&amp;gt; n(n-1)/2&lt;/p>
&lt;p>2、空间复杂度O(1)&lt;/p></description></item><item><title>Docs: 04-快速排序</title><link>https://note.codiy.net/docs/2020/04/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 22 Apr 2020 21:29:26 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>
&lt;h2 id="1-基本思想">1 基本思想&lt;/h2>
&lt;p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。&lt;/p>
&lt;h2 id="2-算法过程">2 算法过程&lt;/h2>
&lt;p>1、从数列中挑出一个元素，称为 “基准”（pivot）；
2、将待排序元素进行分区，比基准值小的元素放在基准值前面，比基准值大的元素放在基准值后面。分区结束后，该基准值就处于数组的中间位置；这个称为分区（partition）操作；
3、递归地（recursive）对左右两个分区重复以上步骤直到所有元素都是有序的。&lt;/p>
&lt;h2 id="3-算法图解">3 算法图解&lt;/h2>
&lt;p>
&lt;p class="md__image">
&lt;img
src="https://img.codiy.net/algorithm/2020/04/quick.gif"
alt="算法图解"
/>
&lt;/p>&lt;/p>
&lt;h2 id="4-php代码实现">4 PHP代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 快速排序: 每次选最左边的点, 将数组划分为左右两部分, 保证右边的比选点大,左边的都比选点小, 对左右两边递归
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 时间复杂度: 最好 O(nlogn) 最差 O(n2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 空间复杂度: O(1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 不稳定排序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">quickSort&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$start&lt;/span>, &lt;span style="color:#00688b">$end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$i&lt;/span> = &lt;span style="color:#00688b">$start&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#00688b">$end&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$pivot&lt;/span> = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$start&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span> (&lt;span style="color:#00688b">$j&lt;/span> &amp;gt; &lt;span style="color:#00688b">$i&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 右边有比选点小的, 扔到左边, 让下一while得以继续
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] &amp;gt;= &lt;span style="color:#00688b">$pivot&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#00688b">$j&lt;/span> &amp;gt; &lt;span style="color:#00688b">$i&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$j&lt;/span>--;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] &amp;lt;= &lt;span style="color:#00688b">$pivot&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span> = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>] = &lt;span style="color:#00688b">$temp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 左边的有比选点大的就,扔到右边, 让上一while得以继续
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>] &amp;lt;= &lt;span style="color:#00688b">$pivot&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#00688b">$j&lt;/span> &amp;gt; &lt;span style="color:#00688b">$i&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$i&lt;/span>++;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>] &amp;gt;= &lt;span style="color:#00688b">$pivot&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span> = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] = &lt;span style="color:#00688b">$temp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 循环结束后，i,j都指向选点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$i&lt;/span> &amp;gt; &lt;span style="color:#00688b">$start&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> quickSort(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$start&lt;/span>, &lt;span style="color:#00688b">$i&lt;/span> - &lt;span style="color:#b452cd">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$j&lt;/span> &amp;lt; &lt;span style="color:#00688b">$end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> quickSort(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#00688b">$end&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$arr&lt;/span> = [&lt;span style="color:#b452cd">38&lt;/span>, &lt;span style="color:#b452cd">19&lt;/span>, &lt;span style="color:#b452cd">29&lt;/span>, &lt;span style="color:#b452cd">91&lt;/span>, &lt;span style="color:#b452cd">85&lt;/span>, &lt;span style="color:#b452cd">12&lt;/span>, &lt;span style="color:#b452cd">41&lt;/span>, &lt;span style="color:#b452cd">21&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>quickSort(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#b452cd">0&lt;/span>, count(&lt;span style="color:#00688b">$arr&lt;/span>) - &lt;span style="color:#b452cd">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print_r(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-效率分析">5 效率分析&lt;/h2>
&lt;p>1、时间复杂度：O(nlogn)
最好的情况：当分区选取的基准元素为待排序元素中的&amp;quot;中值&amp;quot;，时间复杂度为O(nlogn);
最坏的情况：当分区选取的基准元素为待排序元素中的最大或最小值，时间复杂度为O(n²)。
2、空间复杂度：O(log2n)，是不稳定排序。&lt;/p></description></item><item><title>Docs: 05-归并排序</title><link>https://note.codiy.net/docs/2020/04/05-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 22 Apr 2020 21:59:01 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/05-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid><description>
&lt;h2 id="1-基本思想">1 基本思想&lt;/h2>
&lt;p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，使每个子序列有序，再将已有序的子序列合并，得到完全有序的序列。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。&lt;/p>
&lt;h2 id="2-算法过程">2 算法过程&lt;/h2>
&lt;p>1、“分解”——将序列每次折半划分。
2、“合并”——将划分后的序列段两两合并后排序。&lt;/p>
&lt;h2 id="3-算法图解">3 算法图解&lt;/h2>
&lt;p>
&lt;p class="md__image">
&lt;img
src="https://img.codiy.net/algorithm/2020/04/merge.gif"
alt="算法图解"
/>
&lt;/p>&lt;/p>
&lt;h2 id="4-php代码实现">4 PHP代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 归并排序: 对半拆分元素, 拆到底后, 比较左右两边元素, 让其有序后, 回归
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 时间复杂度: O(nlogn)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 空间复杂度: O(n)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 稳定排序(相等元素的顺序不会改变)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">mergeSort&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$start&lt;/span>, &lt;span style="color:#00688b">$end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$start&lt;/span> &amp;lt; &lt;span style="color:#00688b">$end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$mid&lt;/span> = floor((&lt;span style="color:#00688b">$start&lt;/span> + &lt;span style="color:#00688b">$end&lt;/span>) / &lt;span style="color:#b452cd">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mergeSort(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$start&lt;/span>, &lt;span style="color:#00688b">$mid&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mergeSort(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$mid&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#00688b">$end&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> merge(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$start&lt;/span>, &lt;span style="color:#00688b">$mid&lt;/span>, &lt;span style="color:#00688b">$end&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">merge&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$start&lt;/span>, &lt;span style="color:#00688b">$mid&lt;/span>, &lt;span style="color:#00688b">$end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$i&lt;/span> = &lt;span style="color:#00688b">$start&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#00688b">$mid&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span> = [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span>( &lt;span style="color:#00688b">$i&lt;/span> &amp;lt;= &lt;span style="color:#00688b">$mid&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#00688b">$j&lt;/span> &amp;lt;= &lt;span style="color:#00688b">$end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span>(&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>] &amp;lt; &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span>[] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ++&lt;span style="color:#00688b">$i&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#8b008b;font-weight:bold">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span>[] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ++&lt;span style="color:#00688b">$j&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span>(&lt;span style="color:#00688b">$i&lt;/span> &amp;lt;= &lt;span style="color:#00688b">$mid&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span>[] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ++&lt;span style="color:#00688b">$i&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span>(&lt;span style="color:#00688b">$j&lt;/span> &amp;lt;= &lt;span style="color:#00688b">$end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span>[] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ++&lt;span style="color:#00688b">$j&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> (&lt;span style="color:#00688b">$k&lt;/span> = &lt;span style="color:#b452cd">0&lt;/span>; &lt;span style="color:#00688b">$k&lt;/span> &amp;lt; count(&lt;span style="color:#00688b">$temp&lt;/span>); ++&lt;span style="color:#00688b">$k&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$k&lt;/span> + &lt;span style="color:#00688b">$start&lt;/span>] = &lt;span style="color:#00688b">$temp&lt;/span>[&lt;span style="color:#00688b">$k&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$arr&lt;/span> = [&lt;span style="color:#b452cd">38&lt;/span>, &lt;span style="color:#b452cd">19&lt;/span>, &lt;span style="color:#b452cd">29&lt;/span>, &lt;span style="color:#b452cd">91&lt;/span>, &lt;span style="color:#b452cd">85&lt;/span>, &lt;span style="color:#b452cd">12&lt;/span>, &lt;span style="color:#b452cd">41&lt;/span>, &lt;span style="color:#b452cd">21&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mergeSort(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#b452cd">0&lt;/span>, count(&lt;span style="color:#00688b">$arr&lt;/span>) - &lt;span style="color:#b452cd">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print_r(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-效率分析">5 效率分析&lt;/h2>
&lt;p>1、时间复杂度：O(nlogn)
最好情况、最坏情况和平均时间复杂度均为O(nlogn);
2、空间复杂度：O(n)
算法处理过程中，需要一个大小为 n 的临时存储空间保存合并序列，所以空间复杂度为O(n)。
3、稳定性：稳定
在归并排序中，相等的元素的顺序不会改变，所以它是稳定排序。&lt;/p></description></item><item><title>Docs: 06-堆排序</title><link>https://note.codiy.net/docs/2020/04/06-%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 22 Apr 2020 22:23:21 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/06-%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>
&lt;h2 id="0-堆的定义">0 堆的定义&lt;/h2>
&lt;p>堆通常是一个可以被看做一棵树的数组对象，其任一非叶节点满足以下性质：
1、堆中某个节点的值总是不大于或不小于其父节点的值：
　　每个节点的值都大于或等于其左右子节点的值，称为大顶堆。即：arr[i] &amp;gt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;gt;= arr[2i+2]。
　　或：
　　每个节点的值都小于或等于其左右子节点的值，称为小顶堆。即：arr[i] &amp;lt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;lt;= arr[2i+2]。
2、堆总是一棵完全二叉树。
&lt;code>注：上述公式，根节点从0开始。如果根节点从1开始，则左右子节点分别是2i和2i+1。&lt;/code>&lt;/p>
&lt;h2 id="1-基本思想">1 基本思想&lt;/h2>
&lt;p>以大顶堆为例，将待排序的序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将它移走（也就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小的值。如此反复执行，便能得到一个有序序列了。&lt;/p>
&lt;h2 id="2-算法过程">2 算法过程&lt;/h2>
&lt;p>1、将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
2、将堆顶元素与末尾元素交换，将最大元素&amp;quot;沉&amp;quot;到数组末端;
3、重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。&lt;/p>
&lt;h2 id="3-算法图解">3 算法图解&lt;/h2>
&lt;p>
&lt;p class="md__image">
&lt;img
src="https://img.codiy.net/algorithm/2020/04/heap.gif"
alt="算法图解"
/>
&lt;/p>&lt;/p>
&lt;h2 id="4-php代码实现">4 PHP代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 堆排序: 将元素看成完全二叉树, 先从(n/2-1)号元素到0号元素调整为大顶堆, 然后交换首尾值, 继续从0号元素调整
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 时间复杂度: O(nlogn)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 空间复杂度: O(1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * 不稳定排序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">heapSort&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$length&lt;/span> = count(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 调整为大顶堆
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$i&lt;/span> = floor(&lt;span style="color:#00688b">$length&lt;/span>/&lt;span style="color:#b452cd">2&lt;/span> -&lt;span style="color:#b452cd">1&lt;/span>); &lt;span style="color:#00688b">$i&lt;/span> &amp;gt;= &lt;span style="color:#b452cd">0&lt;/span>; --&lt;span style="color:#00688b">$i&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adjustHeap(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$i&lt;/span>, &lt;span style="color:#00688b">$length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 循环交换首尾元素并调整为大顶堆, 直到所有元素有序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#00688b">$length&lt;/span> - &lt;span style="color:#b452cd">1&lt;/span>; &lt;span style="color:#00688b">$j&lt;/span> &amp;gt;= &lt;span style="color:#b452cd">0&lt;/span>; --&lt;span style="color:#00688b">$j&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">list&lt;/span>(&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#b452cd">0&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>]) = [&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>], &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#b452cd">0&lt;/span>]];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adjustHeap(&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#b452cd">0&lt;/span>, &lt;span style="color:#00688b">$j&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">adjustHeap&lt;/span>(&amp;amp;&lt;span style="color:#00688b">$arr&lt;/span>, &lt;span style="color:#00688b">$i&lt;/span>, &lt;span style="color:#00688b">$length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$temp&lt;/span> = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 从当前元素开始遍历左右子节点, 默认从左子节点开始遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span>(&lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#b452cd">2&lt;/span> * &lt;span style="color:#00688b">$i&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>; &lt;span style="color:#00688b">$j&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span>; &lt;span style="color:#00688b">$j&lt;/span> = &lt;span style="color:#b452cd">2&lt;/span> * &lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 如果右子节点比左子节点大,则遍历右子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span> &amp;lt; &lt;span style="color:#00688b">$length&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] &amp;lt; &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span> + &lt;span style="color:#b452cd">1&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$j&lt;/span>++;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 如果当前遍历元素比当前所在子树的根大, 则将其父节点设为当前遍历元素的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (&lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>] &amp;gt; &lt;span style="color:#00688b">$temp&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>] = &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$i&lt;/span> = &lt;span style="color:#00688b">$j&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$arr&lt;/span>[&lt;span style="color:#00688b">$i&lt;/span>] = &lt;span style="color:#00688b">$temp&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$arr&lt;/span> = [&lt;span style="color:#b452cd">38&lt;/span>, &lt;span style="color:#b452cd">19&lt;/span>, &lt;span style="color:#b452cd">29&lt;/span>, &lt;span style="color:#b452cd">91&lt;/span>, &lt;span style="color:#b452cd">85&lt;/span>, &lt;span style="color:#b452cd">12&lt;/span>, &lt;span style="color:#b452cd">41&lt;/span>, &lt;span style="color:#b452cd">21&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>heapSort(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print_r(&lt;span style="color:#00688b">$arr&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-效率分析">5 效率分析&lt;/h2>
&lt;p>1、时间复杂度：O(nlogn)
最坏，最好，平均时间复杂度均为O(nlogn)。
2、空间复杂度：堆排序仅需一个记录大小的供交换用的辅助存储空间，因此空间复杂度为O(1)，是不稳定排序。&lt;/p></description></item></channel></rss>