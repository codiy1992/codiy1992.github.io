<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Codiy's Notebook</title><link>https://note.codiy.net/</link><description>Recent content on Codiy's Notebook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 16 Jan 2022 11:59:15 +0800</lastBuildDate><atom:link href="https://note.codiy.net/index.xml" rel="self" type="application/rss+xml"/><item><title>01-冒泡排序</title><link>https://note.codiy.net/docs/2020/04/01-bubble/</link><pubDate>Tue, 21 Apr 2020 20:54:40 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/01-bubble/</guid><description>1 基本思想 冒泡排序算法是重复地走访要排序的数列，一次比较相邻的两个元素，如果他们的顺序与排序要求相反，就将它们互换，直到没有再需要交换的数字，则说明排序完成。
2 算法过程 1、比较相邻的两个元素，如果前面的数大于后面的数，就将两个数进行交换；
2、从开始第一对到结尾的最后一对，对每一对相邻元素作第1）操作。这步做完后，最大的数就会沉到数组的最后。
3、然后再从头开始，重复第 1 和第 2 操作，直到倒数第二位时结束。
3 算法图解 4 PHP代码实现 /** * 冒泡排序: 循环n-1次, 每次使最大的往后面放, 交换相邻两元素 * 时间复杂度: O(n2) * 空间复杂度: O(1) * 稳定排序 */ function bubbleSort(&amp;amp;$arr) { $length = count($arr); for($i = 1; $i &amp;lt; $length; ++$i) { // 循环 $length - 1 次 for($j = 0; $j &amp;lt; $length - $i ; ++$j) {// 每次使最大的放到最后 if ($arr[$j + 1] &amp;lt; $arr[$j]) {// 交换相邻两元素 list($arr[$j], $arr[$j + 1]) = [$arr[$j + 1], $arr[$j]]; } } } } $arr = [38, 19, 29, 91, 85, 12, 41, 21]; bubbleSort($arr); print_r($arr); 5 效率分析 1、时间复杂度：O(n²) 最好的情况：待排序记录按关键字从小到大排列（正序），需要比较n-1次，时间复杂度为O(n); 最坏的情况：待排序记录按关键字从大到小排列（逆序），需要比较n-1+n-2+…+1=n(n-1)/2，交换次数和比较次数等值，时间复杂度依然为O(n²)。 2、空间复杂度：O(1)，是稳定排序</description></item><item><title>02-插入排序</title><link>https://note.codiy.net/docs/2020/04/02-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link><pubDate>Tue, 21 Apr 2020 21:42:04 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/02-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid><description>1 基本思想 插入排序算法是每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到所有元素插入完毕为止。
2 算法过程 1、将第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；
2、从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面，这样的插入方式，排序是稳定的）。
3 算法图解 4 PHP代码实现 /** * 插入排序: 每次往后多取一个元素, 和现有元素从后往前逐个比较, 比较大,就将现有元素后移一位 * 时间复杂度: O(n2) * 空间复杂度: O(1) * 稳定排序 */ function insertSort(&amp;amp;$arr) { $length = count($arr); for($i = 1; $i &amp;lt; $length; ++$i) {// 每次往后多取一个元素 $temp = $arr[$i]; for($j = $i - 1; $j &amp;gt;= 0; --$j) {// 和现有元素逐个从后往前比较 if ($arr[$j] &amp;gt; $temp) { // 比较大,就将现有元素后移一位 $arr[$j + 1] = $arr[$j]; $arr[$j] = $temp; } else { break; } } } } $arr = [38, 19, 29, 91, 85, 12, 41, 21]; insertSort($arr); print_r($arr); function insertSort2(&amp;amp;$arr) { $length = count($arr); for($i = 1; $i &amp;lt; $length; ++$i) {// 每次往前多取一个元素 for($j = 0; $j &amp;lt; $i; ++$j) {// 和现有元素逐个从前往后比较 if ($arr[$j] &amp;gt; $arr[$i]) { // 找到第一个比它大的元素, 交换, 后续元素往后移一位 list($arr[$i], $arr[$j]) = [$arr[$j], $arr[$i]]; } } } } $arr = [38, 19, 29, 91, 85, 12, 41, 21]; insertSort2($arr); print_r($arr); 5 效率分析 1、时间复杂度：O(n²) 最好的情况：待排序记录按关键字从小到大排列（正序），需要比较n-1次，不需要交换元素，时间复杂度为O(n); 最坏的情况：待排序记录按关键字从大到小排列（逆序），时间复杂度为O(n²)。 2、空间复杂度：O(1)，是稳定排序。</description></item><item><title>03-选择排序</title><link>https://note.codiy.net/docs/2020/04/03-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link><pubDate>Tue, 21 Apr 2020 22:40:14 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/03-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid><description>1 基本思想 选择排序算法是从前往后遍历元素，每次假定当前元素为最小元素，再次遍历剩余元素，找到找到真正最小的元素，交换位置，直到元素有序。
2 算法过程 1、将第一个元素当成最小元素，跟它后面的元素逐个比较，暂存最小元素的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小数 2、下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小数 3、重复以上步骤，直到有序
3 算法图解 4 PHP代码实现 /** * 选择排序: 选一个假定的最小, 找到比他小的, 交换位置 * 时间复杂度: O(n2) * 空间复杂度: O(2) * 稳定排序 */ function selectSort(&amp;amp;$arr) { $length = count($arr); for($i = 0; $i &amp;lt; $length; ++$i) { $minIdx = $i; for($j = $i + 1; $j &amp;lt; $length; ++$j) { if ($arr[$j] &amp;lt; $arr[$minIdx]) { $minIdx = $j; } } if ($minIdx != $i) { list($arr[$minIdx], $arr[$i]) = [$arr[$i], $arr[$minIdx]]; } } } $arr = [38, 19, 29, 91, 85, 12, 41, 21]; selectSort($arr); print_r($arr); 5 效率分析 1、时间复杂度O(n2) (n-1) + (n-2) + &amp;hellip; + 1 ==&amp;gt; n(n-1)/2</description></item><item><title>04-快速排序</title><link>https://note.codiy.net/docs/2020/04/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 22 Apr 2020 21:29:26 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>1 基本思想 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
2 算法过程 1、从数列中挑出一个元素，称为 “基准”（pivot）； 2、将待排序元素进行分区，比基准值小的元素放在基准值前面，比基准值大的元素放在基准值后面。分区结束后，该基准值就处于数组的中间位置；这个称为分区（partition）操作； 3、递归地（recursive）对左右两个分区重复以上步骤直到所有元素都是有序的。
3 算法图解 4 PHP代码实现 /** * 快速排序: 每次选最左边的点, 将数组划分为左右两部分, 保证右边的比选点大,左边的都比选点小, 对左右两边递归 * 时间复杂度: 最好 O(nlogn) 最差 O(n2) * 空间复杂度: O(1) * 不稳定排序 */ function quickSort(&amp;amp;$arr, $start, $end) { $i = $start; $j = $end; $pivot = $arr[$start]; while ($j &amp;gt; $i) { // 右边有比选点小的, 扔到左边, 让下一while得以继续 while ($arr[$j] &amp;gt;= $pivot &amp;amp;&amp;amp; $j &amp;gt; $i) { $j--; } if ($arr[$j] &amp;lt;= $pivot) { $temp = $arr[$j]; $arr[$j] = $arr[$i]; $arr[$i] = $temp; } // 左边的有比选点大的就,扔到右边, 让上一while得以继续 while ($arr[$i] &amp;lt;= $pivot &amp;amp;&amp;amp; $j &amp;gt; $i) { $i++; } if ($arr[$i] &amp;gt;= $pivot) { $temp = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $temp; } } // 循环结束后，i,j都指向选点 if ($i &amp;gt; $start) { quickSort($arr, $start, $i - 1); } if ($j &amp;lt; $end) { quickSort($arr, $j + 1, $end); } } $arr = [38, 19, 29, 91, 85, 12, 41, 21]; quickSort($arr, 0, count($arr) - 1); print_r($arr); 5 效率分析 1、时间复杂度：O(nlogn) 最好的情况：当分区选取的基准元素为待排序元素中的&amp;quot;中值&amp;quot;，时间复杂度为O(nlogn); 最坏的情况：当分区选取的基准元素为待排序元素中的最大或最小值，时间复杂度为O(n²)。 2、空间复杂度：O(log2n)，是不稳定排序。</description></item><item><title>05-归并排序</title><link>https://note.codiy.net/docs/2020/04/05-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 22 Apr 2020 21:59:01 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/05-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid><description>1 基本思想 归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，使每个子序列有序，再将已有序的子序列合并，得到完全有序的序列。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
2 算法过程 1、“分解”——将序列每次折半划分。 2、“合并”——将划分后的序列段两两合并后排序。
3 算法图解 4 PHP代码实现 /** * 归并排序: 对半拆分元素, 拆到底后, 比较左右两边元素, 让其有序后, 回归 * 时间复杂度: O(nlogn) * 空间复杂度: O(n) * 稳定排序(相等元素的顺序不会改变) */ function mergeSort(&amp;amp;$arr, $start, $end) { if ($start &amp;lt; $end) { $mid = floor(($start + $end) / 2); mergeSort($arr, $start, $mid); mergeSort($arr, $mid + 1, $end); merge($arr, $start, $mid, $end); } } function merge(&amp;amp;$arr, $start, $mid, $end) { $i = $start; $j = $mid + 1; $temp = []; while( $i &amp;lt;= $mid &amp;amp;&amp;amp; $j &amp;lt;= $end) { if($arr[$i] &amp;lt; $arr[$j]) { $temp[] = $arr[$i]; ++$i; } else { $temp[] = $arr[$j]; ++$j; } } while($i &amp;lt;= $mid) { $temp[] = $arr[$i]; ++$i; } while($j &amp;lt;= $end) { $temp[] = $arr[$j]; ++$j; } for ($k = 0; $k &amp;lt; count($temp); ++$k) { $arr[$k + $start] = $temp[$k]; } } $arr = [38, 19, 29, 91, 85, 12, 41, 21]; mergeSort($arr, 0, count($arr) - 1); print_r($arr); 5 效率分析 1、时间复杂度：O(nlogn) 最好情况、最坏情况和平均时间复杂度均为O(nlogn); 2、空间复杂度：O(n) 算法处理过程中，需要一个大小为 n 的临时存储空间保存合并序列，所以空间复杂度为O(n)。 3、稳定性：稳定 在归并排序中，相等的元素的顺序不会改变，所以它是稳定排序。</description></item><item><title>06-堆排序</title><link>https://note.codiy.net/docs/2020/04/06-%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 22 Apr 2020 22:23:21 +0800</pubDate><guid>https://note.codiy.net/docs/2020/04/06-%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>0 堆的定义 堆通常是一个可以被看做一棵树的数组对象，其任一非叶节点满足以下性质： 1、堆中某个节点的值总是不大于或不小于其父节点的值： 每个节点的值都大于或等于其左右子节点的值，称为大顶堆。即：arr[i] &amp;gt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;gt;= arr[2i+2]。 或： 每个节点的值都小于或等于其左右子节点的值，称为小顶堆。即：arr[i] &amp;lt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;lt;= arr[2i+2]。 2、堆总是一棵完全二叉树。 注：上述公式，根节点从0开始。如果根节点从1开始，则左右子节点分别是2i和2i+1。
1 基本思想 以大顶堆为例，将待排序的序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将它移走（也就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小的值。如此反复执行，便能得到一个有序序列了。
2 算法过程 1、将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 2、将堆顶元素与末尾元素交换，将最大元素&amp;quot;沉&amp;quot;到数组末端; 3、重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
3 算法图解 4 PHP代码实现 /** * 堆排序: 将元素看成完全二叉树, 先从(n/2-1)号元素到0号元素调整为大顶堆, 然后交换首尾值, 继续从0号元素调整 * 时间复杂度: O(nlogn) * 空间复杂度: O(1) * 不稳定排序 */ function heapSort(&amp;amp;$arr) { $length = count($arr); // 调整为大顶堆 for($i = floor($length/2 -1); $i &amp;gt;= 0; --$i) { adjustHeap($arr, $i, $length); } // 循环交换首尾元素并调整为大顶堆, 直到所有元素有序 for($j = $length - 1; $j &amp;gt;= 0; --$j) { list($arr[0], $arr[$j]) = [$arr[$j], $arr[0]]; adjustHeap($arr, 0, $j); } } function adjustHeap(&amp;amp;$arr, $i, $length) { $temp = $arr[$i]; // 从当前元素开始遍历左右子节点, 默认从左子节点开始遍历 for($j = 2 * $i + 1; $j &amp;lt; $length; $j = 2 * $j + 1) { // 如果右子节点比左子节点大,则遍历右子树 if ($j + 1 &amp;lt; $length &amp;amp;&amp;amp; $arr[$j] &amp;lt; $arr[$j + 1]) { $j++; } // 如果当前遍历元素比当前所在子树的根大, 则将其父节点设为当前遍历元素的值 if ($arr[$j] &amp;gt; $temp) { $arr[$i] = $arr[$j]; $i = $j; } } $arr[$i] = $temp; } $arr = [38, 19, 29, 91, 85, 12, 41, 21]; heapSort($arr); print_r($arr); 5 效率分析 1、时间复杂度：O(nlogn) 最坏，最好，平均时间复杂度均为O(nlogn)。 2、空间复杂度：堆排序仅需一个记录大小的供交换用的辅助存储空间，因此空间复杂度为O(1)，是不稳定排序。</description></item><item><title>Caddy Usage</title><link>https://note.codiy.net/docs/2022/01/caddy-usage/</link><pubDate>Sun, 16 Jan 2022 11:59:15 +0800</pubDate><guid>https://note.codiy.net/docs/2022/01/caddy-usage/</guid><description>Build your own caddy images Dockerfile:
FROMcaddy:builder AS builderRUN xcaddy build \ --with github.com/caddy-dns/alidnsFROMcaddyCOPY --from=builder /usr/bin/caddy /usr/bin/caddyCaddy TLS Settings Caddyfile Syntax:
tls [internal|&amp;lt;email&amp;gt;] | [&amp;lt;cert_file&amp;gt; &amp;lt;key_file&amp;gt;] { protocols &amp;lt;min&amp;gt; [&amp;lt;max&amp;gt;] ciphers &amp;lt;cipher_suites...&amp;gt; curves &amp;lt;curves...&amp;gt; alpn &amp;lt;values...&amp;gt; load &amp;lt;paths...&amp;gt; ca &amp;lt;ca_dir_url&amp;gt; ca_root &amp;lt;pem_file&amp;gt; key_type ed25519|p256|p384|rsa2048|rsa4096 dns &amp;lt;provider_name&amp;gt; [&amp;lt;params...&amp;gt;] resolvers &amp;lt;dns_servers...&amp;gt; eab &amp;lt;key_id&amp;gt; &amp;lt;mac_key&amp;gt; on_demand client_auth { mode [request|require|verify_if_given|require_and_verify] trusted_ca_cert &amp;lt;base64_der&amp;gt; trusted_ca_cert_file &amp;lt;filename&amp;gt; trusted_leaf_cert &amp;lt;base64_der&amp;gt; trusted_leaf_cert_file &amp;lt;filename&amp;gt; } issuer &amp;lt;issuer_name&amp;gt; [&amp;lt;params...&amp;gt;] } 常见配置方式 Caddy Automatic Https</description></item><item><title>anki</title><link>https://note.codiy.net/docs/2022/01/anki/</link><pubDate>Wed, 05 Jan 2022 17:31:00 +0800</pubDate><guid>https://note.codiy.net/docs/2022/01/anki/</guid><description>Anki Awesome-anki tianshanghong/awesome-anki Add-ons(required) Review Heatmap Custom Background Image and Gear Icon No Distractions Full Screen: Clean review interface + Tablet/Touch support AnkiConnect Minimal Theme More Decks Stats and Time Left Button Colours (Good, Again) extended editor for field (for tables, search&amp;amp;replace, &amp;hellip;) AnkiWebView Inspector Advanced Copy Fields Progress Graphs and Stats for Learned and Matured Cards AwesomeTTS (Google Cloud Text-to-Speech &amp;amp; Microsoft Azure TTS) [unofficial] Advanced Browser Highlight Search Results in the Browser Fastbar- with nightmode support Always On Top Replay buttons on card CrowdAnki: JSON export&amp;amp;import.</description></item><item><title>All In One</title><link>https://note.codiy.net/docs/2022/01/all-in-one/</link><pubDate>Wed, 05 Jan 2022 17:30:19 +0800</pubDate><guid>https://note.codiy.net/docs/2022/01/all-in-one/</guid><description>宽带与光猫 宽带是否支持多播 光猫管理员账号密码 光猫由路由模式设置为桥接模式 拨号发现为局域网IP, 打给客服要求分配公网IP 软路由 CPU: J4125 网卡 i210 or i211 千兆网卡 内存条 存储 ESXi 官网镜像下载, ventoy 制作启动U盘 开机进 BIOS 选择引导方式优先级 进入 ESXi 安装界面, 快速按 Shift + o, 输入命令 限制缓存用的磁盘大小 安装完后, 管理网口选到 eht0, 然后设置IP地址 用网线将 eth0 与电脑连接。 电脑上设置IPV4属性，使得可以桥接到 ESXi. 电脑上浏览器输入 ESXi 管理地址，进行虚拟机管理. ROS OpenWrt 光猫，路由，网关，交换机，网桥，DNS，DHCP, NAT References aimuch/iAI</description></item><item><title>English Phonetic Symbol</title><link>https://note.codiy.net/docs/2022/01/english-phonetic-symbol/</link><pubDate>Wed, 05 Jan 2022 13:11:52 +0800</pubDate><guid>https://note.codiy.net/docs/2022/01/english-phonetic-symbol/</guid><description>音标的历史 IPA国际音标 国际音标（广义），又称国际语音字母（英文International Phonetic Alphabet，简称IPA），以拉丁字母为基础的一套用来标音的系统，是用于为全世界所有语言注音的符号系统。其最早源于1888年，由国际语音协会(International Phonetic Association)设计的。
英国音标: Daniel Jones(DJ音标), Gimson, Clive Upton DJ音标跟英国语音学家Daniel Jones有关（名字首字母Ｄ和Ｊ）。他根据IPA编了一本英国英语的发音辞典English Pronouncing Dictionary（第1版至第12版，最后一版的出版时间为1963）。他所编的英语发音字典代表了被称为 “Received Pronunciation”（RP）（标准发音）的读音，这在受过教育的英国人尤其是南部英格兰人中通用。
凡是英语教学或学习辞典，只要是教英国音的，无不奉这本辞典为圭臬。
可是到了现在，这种标准已经过时落伍了。英国另一位语音学家A. C. Gimson（他是Daniel Jones的学生，英国伦敦大学的语音学教授），将英国英语的辞典发音做了一番修正（第13版，1977；第14版，1988），使它更能代表实际发音。
后来又有牛津的 Clive Upton 在 Gimson 的版本上修改了5个元音符号, 被用在牛津词典当中, 参见IPA vowel symbols for British English in dictionaries
美国音标: Kenyon&amp;amp;Knott(KK音标) KK音标也是国际音标的一种，是《美式英语发音辞典》（A Pronouncing Dictionary of American English）所使用的音标，由美国两位语言学家John S. Kenyou和Thomas A. Knott共同研究出来。由于两位作者的姓皆以K开头，所以一般称为KK音标。
而由于教育传统等原因，美国本土的学生并不学习KK音标，而是使用更能标示他们实际发音习惯的重拼法（respelling）或Merriam-Webster’s系列词典使用的标音法（有的译为韦氏音标）。像apathy这个单词，传统式重拼法就标音为（ap-ath-ee）。
如，美国传统词典音标AHD（American Heritage Dictionary）的标音方法属于重拼法。如今，为了方便交流（或者商业利益？），也有越来越多的英国母语辞典也改用国际音标，有的还营销到国外，而美国辞典则大都停留在使用各自的重拼法来注音。
IPA63(DJ音标）、KK音标和IPA88（新版DJ音标）的对比图 IPA英语音标对照表 Comparison of the IPA variants for English Lexical sets Jones Gimson Upton Kenyon&amp;amp;Knott Roach et al.</description></item><item><title>Essential Grammars in Use</title><link>https://note.codiy.net/docs/2022/01/essential-grammars-in-use/</link><pubDate>Wed, 05 Jan 2022 13:11:52 +0800</pubDate><guid>https://note.codiy.net/docs/2022/01/essential-grammars-in-use/</guid><description>1 Tenses Unit001 - Unit028
1.1 Present Continuous am/is/are + -ing = something is happening now short form you're not or you aren't short answers positive, negative, question having, doing Some verbs don&amp;rsquo;t be used in the present continuous
want like know prefer believe need mean forget remember understand 1.</description></item><item><title>ROS Settings</title><link>https://note.codiy.net/docs/2022/01/ros-settings/</link><pubDate>Wed, 05 Jan 2022 11:42:08 +0800</pubDate><guid>https://note.codiy.net/docs/2022/01/ros-settings/</guid><description>基础设定 设置IP地址 /ip address add address=192.168.1.1/24 comment=&amp;quot;default configuration&amp;quot; interface=lan1 network=192.168.1.0 PPPOE 拨号上网 /interface ethernet set [ find default-name=ether1 ] name=lan1 set [ find default-name=ether2 ] name=wan1 /interface pppoe-client add name=pppoe interface=wan1 user=xxxx password=yyyy add-default-route=yes disabled=no 开启IP伪装共享上网(源地址为本局域网IP的IP数据包, 统一替换为路由器公网IP) /ip firewall nat add chain=srcnat action=masquerade 设置DNS /ip dns set allow-remote-requests=yes servers=218.85.157.99,218.85.152.99 配置 dhcp 服务 /ip pool add name=dhcp_pool0 ranges=192.168.1.5-192.168.1.253 /ip dhcp-server add name=dhcp interface=lan1 address-pool=dhcp_pool0 lease-time=10m /ip dhcp-server network add address=192.</description></item><item><title>About</title><link>https://note.codiy.net/about/</link><pubDate>Thu, 30 Dec 2021 13:01:24 +0800</pubDate><guid>https://note.codiy.net/about/</guid><description/></item><item><title>How I Manage My Dotfiles</title><link>https://note.codiy.net/docs/2021/12/how-i-manage-my-dotfiles/</link><pubDate>Wed, 29 Dec 2021 16:09:48 +0800</pubDate><guid>https://note.codiy.net/docs/2021/12/how-i-manage-my-dotfiles/</guid><description>1. What is dofiles The definition by archlinux, User-specific application configuration is traditionally stored in so called dotfiles (files whose filename starts with a dot). Some of them listed below:
.vimrc .tmux.conf .gitconfig .ssh/ .aws/ .gnupg/ .config/ Those dotfiles are all located in your home directory.
2. Best way to manage dotfiles Bare repository and alias method is the best way to keep track of changes and synchronize your dotfiles between hosts.</description></item><item><title>Proxy Setting</title><link>https://note.codiy.net/docs/2021/03/proxy-setting/</link><pubDate>Wed, 10 Mar 2021 09:23:01 +0800</pubDate><guid>https://note.codiy.net/docs/2021/03/proxy-setting/</guid><description>详细参考: https://about.gitlab.com/blog/2021/01/27/we-need-to-talk-no-proxy/
http_proxy and https_proxy 小写格式总是被支持的, 大写格式不一定被支持 no_proxy 使用小写格式 可以使用 hostname:port 的格式 使用域名后缀匹配(e.g. example.com 会匹配 test.example.com) 要匹配顶级域名,需避免在域名前面有.号 避免使用CIDR格式, 因为只有 Go 和 Ruby 支持. 腾讯云需设置 export no_proxy=mirrors.tencentyun.com 否则无法使用 yum ssh 代理设置 安装依赖程序 sudo yum install nmap or sudo apt-get install nmap 编辑 ~/.ssh/config 添加如下配置 Host github.com HostName github.com ProxyCommand /usr/bin/ncat --proxy 127.0.0.1:7091 --proxy-type socks5 %h %p</description></item><item><title>Exploiting PHP deserialization And SSRF</title><link>https://note.codiy.net/docs/2021/02/php-deserialization-and-ssrf-exploiting/</link><pubDate>Sat, 27 Feb 2021 09:16:52 +0800</pubDate><guid>https://note.codiy.net/docs/2021/02/php-deserialization-and-ssrf-exploiting/</guid><description>1 - 反序列化利用链 1.1 基础知识和原理 反序列化会从给定的序列化串来还原对象,并调用 __wakeup 来做唤醒工作, 而不调用 __construct 来初始化对象 还原的对象会带上序列化时指定的属性, 这部分可被利用来作为恶意代码输入点. 恶意代码仅放在属性中并不会被执行, 所以一般利用 __destruct 在对象销毁的时候,通过巧妙构造传递属性来让恶意代码被执行, 这中间可能还需要借助其他类对象. 因此, 只要存在受用户控制的反序列化入口, 即可通过特别构造的序列化串来达到搞事情的目的. 1.2 利用形式(反序列化入口) 直接调用反序列化函数, unserialize(base64_decode($_POST['serialized_string'])); 下列函数在载入phar 时候也会触发反序列化, 如 is_dir('phar://phar.gif') column1 column2 column3 column4 column5 column6 fileatime filectime filemtime file_exists file_get_contents file_put_contents file filegroup fopen fileinode fileowner fileperms is_dir is_file is_link is_executable is_readable is_writeable is_wirtble parse_ini_file copy unlink stat readfile phar 文件本地生成需 php.</description></item><item><title>rhaphp</title><link>https://note.codiy.net/docs/2021/02/rhaphp/</link><pubDate>Sat, 27 Feb 2021 09:16:52 +0800</pubDate><guid>https://note.codiy.net/docs/2021/02/rhaphp/</guid><description>RhaPHP介绍 一款半开源的微信第三方管理平台, 部分扩展功能插件是收费的. 项目地址:https://github.com/geesondog/rhaphp 1.5.8版本存在的安全问题 默认开启 info 级别日志, 日志可通过 http 请求直接下载, 下载路径 /runtime/log/202102/27.log, info 级别日志将会包含后台登陆账号的 cookie 信息. 真香!!! 存在ssrf漏洞路由 mp/mp/addKeyword POST 参数 keyword=abc&amp;amp;type=image&amp;amp;reply_image=dict://redis:6379/flushall&amp;amp;image_staus_type=0 可利用ssrf漏洞上传任意格式文件,但无法确定保存的文件名 RhaPHP1.5.8 版本使用的是 ThinkPHP5.1.35 框架, 存在反序列化利用链, 但还没找到合适的利用入口. 图片上传仅检查后缀, 可通过 phar 文件绕过上传限制, 再配合反序列化入口函数进行爆破(但目前没有找到入口) 上传文件直接使用的是文件md5作为文件名和路径, 可再本地模拟后获得上传后的最终路径 低版本存在另一个ssrf漏洞, /mp/show/image?url=file:///etc/passwd</description></item><item><title>shopxo</title><link>https://note.codiy.net/docs/2021/02/shopxo/</link><pubDate>Sat, 27 Feb 2021 09:16:52 +0800</pubDate><guid>https://note.codiy.net/docs/2021/02/shopxo/</guid><description>shopxo介绍 一款半开源的企业级B2C免费开源电商系统. 项目地址:https://github.com/gongfuxiang/shopxo 存在的安全问题 存在ssrf漏洞和反序列化利用链, 入口: index.php?s=/index/qrcode/download&amp;amp;url=$(echo -n 'file:///etc/passwd' | base64) | tr -d '\n' 存在许多演示站点, 默认账号密码 shopxo:shopxo</description></item><item><title>Gnupg Usage</title><link>https://note.codiy.net/docs/2020/11/gnupg-usage/</link><pubDate>Wed, 18 Nov 2020 15:20:27 +0800</pubDate><guid>https://note.codiy.net/docs/2020/11/gnupg-usage/</guid><description>gnupg 简介 采用主密码 + 非对称密钥对的形式进行信息的加解密 只有主密码或者只有密钥对均不能正常加解密, 得配合起来用. 私钥的导入和导出,都需要验证主密码 应用一(A,B双方文件加密传输): A用B的公钥对文档进行加密后传送给B, B拿到加密文档后用B的私钥进行解密得到原文档. 应用二(A,B双方进行文件加密并签名): A用B的公钥对文档进行加密,并用A自己的私钥进行签名(签章), B拿到后用B的私钥进行解密,并用A的公钥进行验签. gnupg 使用 创建新密钥对 gpg --full-gen-key 导入私钥(公钥可由私钥生成，无需导入) // 导入公钥或私钥 gpg --import xxx.pub.key gpg --import xxx.sec.key 信任密钥 // 方式1 cat &amp;#39;trusted-key B2980F3D615692897D3F344FAC8E655219F3ABB3&amp;#39; &amp;gt;&amp;gt; ~/.gnupg/gpg.conf // 方式2, 选5 I trust ultimately gpg --edit-key &amp;lt;user-id&amp;gt; trust 列出公钥私钥 gpg --list-keys gpg --list-secret-keys 加密，解密，签名 // 加密文档, 使用对方公钥进行加密 gpg --recipient &amp;lt;user-id&amp;gt; --encrypt doc // 解密文档 gpg --decrypt doc.</description></item></channel></rss>